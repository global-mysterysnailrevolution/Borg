{# ============================================================================
   Template: mcp_server.py.j2
   Purpose : Auto-generate a complete FastMCP server for any discovered tool.
   Author  : HackForge ToolForge code-generation engine

   Required context variables
   --------------------------
   tool_name      str   — Human-readable tool name (e.g. "Brave Search")
   module_name    str   — Python-safe module name (e.g. "brave_search")
   env_var_name   str   — Environment variable holding the API key
                          (e.g. "BRAVE_SEARCH_API_KEY")
   base_url       str   — API base URL (e.g. "https://api.search.brave.com/res/v1")
   timeout        int   — Request timeout in seconds (default: 30)
   auth_type      str   — "bearer" | "api_key_header" | "api_key_query" | "none"
   api_key_header str   — Header name when auth_type is "api_key_header"
                          (e.g. "X-Subscription-Token")
   endpoints      list  — List of endpoint descriptor dicts, each containing:
       function_name   str   — Python function name (snake_case)
       method          str   — HTTP method (GET, POST, …)
       path            str   — URL path relative to base_url
       description     str   — One-line docstring
       params_signature str  — Python parameter signature string
                               (e.g. "query: str, max_results: int = 10")
       has_body        bool  — Whether the call sends a JSON body
       body_template   str   — Python dict literal for json= kwarg
                               (only when has_body is true)
       query_params    list  — List of {name, param} dicts for query params
                               (only when has_body is false)
   ============================================================================ #}
"""MCP server for {{ tool_name }} — auto-generated by HackForge ToolForge.

Do not edit this file by hand; regenerate it from the template:
    hackforge/templates/mcp_server.py.j2
"""

from __future__ import annotations

import json
import logging
import os
from typing import Any

import httpx
from mcp.server.fastmcp import FastMCP

# ---------------------------------------------------------------------------
# Logging
# ---------------------------------------------------------------------------

logger = logging.getLogger("{{ module_name }}-mcp")

# ---------------------------------------------------------------------------
# Server instance
# ---------------------------------------------------------------------------

mcp = FastMCP("{{ tool_name }}")

# ---------------------------------------------------------------------------
# Configuration
# ---------------------------------------------------------------------------

{% if env_var_name %}
API_KEY: str = os.environ.get("{{ env_var_name }}", "")
{% else %}
API_KEY: str = ""
{% endif %}
BASE_URL: str = "{{ base_url }}"
TIMEOUT: int = {{ timeout | default(30) }}

# ---------------------------------------------------------------------------
# Internal HTTP helper
# ---------------------------------------------------------------------------


def _build_headers() -> dict[str, str]:
    """Build request headers according to the tool's auth scheme."""
{% if auth_type == "bearer" %}
    return {
        "Authorization": f"Bearer {API_KEY}",
        "Content-Type": "application/json",
        "Accept": "application/json",
    }
{% elif auth_type == "api_key_header" %}
    return {
        "{{ api_key_header | default('X-API-Key') }}": API_KEY,
        "Content-Type": "application/json",
        "Accept": "application/json",
    }
{% elif auth_type == "api_key_query" %}
    # API key is passed as a query parameter; only content negotiation headers here
    return {
        "Content-Type": "application/json",
        "Accept": "application/json",
    }
{% else %}
    return {
        "Content-Type": "application/json",
        "Accept": "application/json",
    }
{% endif %}


async def _request(
    method: str,
    path: str,
    *,
    params: dict[str, Any] | None = None,
    json_body: dict[str, Any] | None = None,
) -> dict[str, Any]:
    """Execute an authenticated HTTP request against the {{ tool_name }} API.

    Args:
        method: HTTP verb (GET, POST, etc.).
        path: URL path relative to BASE_URL.
        params: Optional query-string parameters.
        json_body: Optional JSON request body.

    Returns:
        Parsed JSON response as a Python dict.

    Raises:
        httpx.HTTPStatusError: On 4xx/5xx responses.
        httpx.TimeoutException: When the request exceeds TIMEOUT seconds.
    """
{% if auth_type == "api_key_query" %}
    merged_params: dict[str, Any] = {"api_key": API_KEY}
    if params:
        merged_params.update(params)
    params = merged_params
{% endif %}

    async with httpx.AsyncClient(
        base_url=BASE_URL,
        timeout=TIMEOUT,
        follow_redirects=True,
    ) as client:
        response = await client.request(
            method,
            path,
            headers=_build_headers(),
            params=params,
            json=json_body,
        )
        response.raise_for_status()

        # Some endpoints return 204 No Content
        if not response.content:
            return {}

        return response.json()


# ---------------------------------------------------------------------------
# MCP tool definitions
# ---------------------------------------------------------------------------

{% for endpoint in endpoints %}
@mcp.tool()
async def {{ endpoint.function_name }}({{ endpoint.params_signature }}) -> str:
    """{{ endpoint.description }}

    Returns:
        JSON-formatted string containing the API response.
    """
    logger.debug(
        "Calling {{ tool_name }} %s %s",
        "{{ endpoint.method }}",
        "{{ endpoint.path }}",
    )
{% if endpoint.has_body %}
    result = await _request(
        "{{ endpoint.method }}",
        "{{ endpoint.path }}",
        json_body={{ endpoint.body_template }},
    )
{% elif endpoint.query_params %}
    _params: dict[str, Any] = {
{% for qp in endpoint.query_params %}
        "{{ qp.name }}": {{ qp.param }},
{% endfor %}
    }
    # Remove None values so optional params are omitted from the query string
    _params = {k: v for k, v in _params.items() if v is not None}
    result = await _request(
        "{{ endpoint.method }}",
        "{{ endpoint.path }}",
        params=_params,
    )
{% else %}
    result = await _request("{{ endpoint.method }}", "{{ endpoint.path }}")
{% endif %}
    return json.dumps(result, indent=2, default=str)

{% endfor %}

# ---------------------------------------------------------------------------
# Entry point
# ---------------------------------------------------------------------------


def main() -> None:
    """Run the {{ tool_name }} MCP server over stdio transport."""
    if not API_KEY{% if auth_type == "none" %} and "{{ auth_type }}" != "none"{% endif %}:
        logger.warning(
            "{{ env_var_name }} is not set — authenticated calls will fail."
        )
    mcp.run(transport="stdio")


if __name__ == "__main__":
    main()
