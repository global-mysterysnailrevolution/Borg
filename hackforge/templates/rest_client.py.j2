{# ============================================================================
   Template: rest_client.py.j2
   Purpose : Auto-generate a typed async REST client for any discovered tool.
   Author  : HackForge ToolForge code-generation engine

   Required context variables
   --------------------------
   tool_name      str   — Human-readable tool name (e.g. "Brave Search")
   module_name    str   — Python-safe module name (e.g. "brave_search")
   class_name     str   — PascalCase client class name (e.g. "BraveSearchClient")
   base_url       str   — Default API base URL
   timeout        int   — Default request timeout in seconds
   auth_type      str   — "bearer" | "api_key_header" | "api_key_query" | "none"
   api_key_header str   — Custom header name when auth_type == "api_key_header"
   endpoints      list  — List of endpoint descriptor dicts:
       function_name      str   — Python method name (snake_case)
       method             str   — HTTP verb
       path               str   — URL path (may contain {placeholders})
       description        str   — Docstring for the method
       params_with_types  str   — ", key: type = default" comma-prefixed string
                                  (starts with ", " so it follows "self")
       has_body           bool  — True when the request sends a JSON body
       body_template      str   — Python dict literal for json= kwarg
       query_params       list  — [{name, param}] for query-string parameters
       path_params        list  — [str] names of path placeholders in `path`
       return_type        str   — Python return-type hint (default "dict")
   ============================================================================ #}
"""REST client for {{ tool_name }} — auto-generated by HackForge ToolForge.

Do not edit this file by hand; regenerate it from the template:
    hackforge/templates/rest_client.py.j2
"""

from __future__ import annotations

import logging
from typing import Any

import httpx

logger = logging.getLogger("{{ module_name }}_client")


class {{ class_name }}Error(Exception):
    """Base exception for {{ class_name }} errors."""


class {{ class_name }}AuthError({{ class_name }}Error):
    """Raised when the API key is rejected (HTTP 401/403)."""


class {{ class_name }}RateLimitError({{ class_name }}Error):
    """Raised when the rate limit is exceeded (HTTP 429)."""


class {{ class_name }}APIError({{ class_name }}Error):
    """Raised for any unexpected non-2xx API response."""


class {{ class_name }}:
    """Async REST client for the {{ tool_name }} API.

    Usage::

        async with {{ class_name }}(api_key="...") as client:
{% for endpoint in endpoints %}
            result = await client.{{ endpoint.function_name }}(...)
{% endfor %}

    All methods return a ``dict`` parsed from the JSON response body.
    An empty dict is returned for 204 No Content responses.
    """

    DEFAULT_BASE_URL: str = "{{ base_url }}"
    DEFAULT_TIMEOUT: int = {{ timeout | default(30) }}

    def __init__(
        self,
{% if auth_type != "none" %}
        api_key: str,
{% endif %}
        base_url: str = DEFAULT_BASE_URL,
        timeout: int = DEFAULT_TIMEOUT,
    ) -> None:
{% if auth_type != "none" %}
        self.api_key = api_key
{% endif %}
        self.base_url = base_url
        self.timeout = timeout
        self._client: httpx.AsyncClient | None = None

    # ------------------------------------------------------------------
    # Context manager support
    # ------------------------------------------------------------------

    async def __aenter__(self) -> {{ class_name }}:
        await self._ensure_client()
        return self

    async def __aexit__(self, *_: Any) -> None:
        await self.close()

    async def _ensure_client(self) -> None:
        if self._client is None:
            self._client = httpx.AsyncClient(
                base_url=self.base_url,
                timeout=self.timeout,
                follow_redirects=True,
            )

    async def close(self) -> None:
        """Release the underlying HTTP connection pool."""
        if self._client is not None:
            await self._client.aclose()
            self._client = None

    # ------------------------------------------------------------------
    # Auth helpers
    # ------------------------------------------------------------------

    def _build_headers(self) -> dict[str, str]:
        """Construct per-request headers according to the auth scheme."""
{% if auth_type == "bearer" %}
        return {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json",
            "Accept": "application/json",
        }
{% elif auth_type == "api_key_header" %}
        return {
            "{{ api_key_header | default('X-API-Key') }}": self.api_key,
            "Content-Type": "application/json",
            "Accept": "application/json",
        }
{% else %}
        return {
            "Content-Type": "application/json",
            "Accept": "application/json",
        }
{% endif %}

{% if auth_type == "api_key_query" %}
    def _inject_api_key(self, params: dict[str, Any] | None) -> dict[str, Any]:
        """Merge the API key into the query-string parameters dict."""
        merged: dict[str, Any] = {"api_key": self.api_key}
        if params:
            merged.update(params)
        return merged

{% endif %}
    # ------------------------------------------------------------------
    # Internal HTTP transport
    # ------------------------------------------------------------------

    async def _request(
        self,
        method: str,
        path: str,
        *,
        params: dict[str, Any] | None = None,
        json_body: dict[str, Any] | None = None,
    ) -> dict[str, Any]:
        """Send an authenticated HTTP request and return parsed JSON.

        Args:
            method: HTTP verb.
            path: URL path relative to ``base_url``.
            params: Optional query-string parameters; ``None`` values are
                dropped automatically.
            json_body: Optional JSON request body.

        Returns:
            Parsed response body, or ``{}`` for 204 No Content.

        Raises:
            {{ class_name }}AuthError: On HTTP 401 or 403.
            {{ class_name }}RateLimitError: On HTTP 429.
            {{ class_name }}APIError: On any other non-2xx response.
        """
        await self._ensure_client()
        assert self._client is not None  # for type-checkers

        # Strip None values from query params
        clean_params: dict[str, Any] | None = None
        if params:
            clean_params = {k: v for k, v in params.items() if v is not None}
{% if auth_type == "api_key_query" %}
        clean_params = self._inject_api_key(clean_params)
{% endif %}

        try:
            response = await self._client.request(
                method,
                path,
                headers=self._build_headers(),
                params=clean_params,
                json=json_body,
            )
        except httpx.TimeoutException as exc:
            raise {{ class_name }}APIError(
                f"Request timed out after {self.timeout}s: {exc}"
            ) from exc
        except httpx.RequestError as exc:
            raise {{ class_name }}APIError(f"Network error: {exc}") from exc

        # Map well-known error codes to typed exceptions
        if response.status_code in (401, 403):
            raise {{ class_name }}AuthError(
                f"Authentication failed (HTTP {response.status_code}): "
                f"{response.text[:200]}"
            )
        if response.status_code == 429:
            retry_after = response.headers.get("Retry-After", "unknown")
            raise {{ class_name }}RateLimitError(
                f"Rate limit exceeded. Retry-After: {retry_after}"
            )
        if response.status_code >= 400:
            raise {{ class_name }}APIError(
                f"API error {response.status_code}: {response.text[:500]}"
            )

        if not response.content:
            return {}

        return response.json()

    # ------------------------------------------------------------------
    # API methods
    # ------------------------------------------------------------------

{% for endpoint in endpoints %}
    async def {{ endpoint.function_name }}(
        self{{ endpoint.params_with_types }},
    ) -> {{ endpoint.return_type | default("dict") }}:
        """{{ endpoint.description }}

        Returns:
            Parsed JSON response body.
        """
        logger.debug(
            "{{ class_name }}.{{ endpoint.function_name }} → %s %s",
            "{{ endpoint.method }}",
            "{{ endpoint.path }}",
        )
{% if endpoint.path_params %}
        _path = "{{ endpoint.path }}".format(
{% for pp in endpoint.path_params %}
            {{ pp }}={{ pp }},
{% endfor %}
        )
{% else %}
        _path = "{{ endpoint.path }}"
{% endif %}
{% if endpoint.has_body %}
        return await self._request(
            "{{ endpoint.method }}",
            _path,
            json_body={{ endpoint.body_template }},
        )
{% elif endpoint.query_params %}
        _params: dict[str, Any] = {
{% for qp in endpoint.query_params %}
            "{{ qp.name }}": {{ qp.param }},
{% endfor %}
        }
        return await self._request(
            "{{ endpoint.method }}",
            _path,
            params=_params,
        )
{% else %}
        return await self._request("{{ endpoint.method }}", _path)
{% endif %}

{% endfor %}
