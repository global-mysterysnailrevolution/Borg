"""Tool Forge Engine — Auto-generation of MCP Servers and REST Clients.

Takes a tool name and an API documentation URL, then:
  1. Fetches and parses the API docs.
  2. Extracts a structured endpoint specification via Fastino.
  3. Renders MCP server boilerplate via Jinja2 templates.
  4. Writes the generated files to ``mcp-servers/{tool_name}-mcp/``.
  5. Updates the harness ``tool-broker.md``.
  6. Returns a :class:`ForgeResult` describing what was created.
"""

from __future__ import annotations

import json
import logging
import re
from datetime import datetime, timezone
from pathlib import Path
from typing import Any

import httpx
from pydantic import BaseModel, Field

from hackforge.config import HackForgeConfig

logger = logging.getLogger(__name__)


# ---------------------------------------------------------------------------
# Pydantic models
# ---------------------------------------------------------------------------


class Endpoint(BaseModel):
    """A single API endpoint parsed from documentation."""

    method: str = "GET"  # HTTP verb: GET, POST, PUT, DELETE, PATCH
    path: str = "/"
    description: str = ""
    params: list[dict[str, Any]] = Field(default_factory=list)
    response_schema: dict[str, Any] = Field(default_factory=dict)
    requires_auth: bool = True


class APISpec(BaseModel):
    """Structured representation of an API extracted from its documentation."""

    name: str
    base_url: str = ""
    auth_type: str = "api_key"  # "api_key" | "oauth" | "bearer" | "none"
    auth_header: str = "Authorization"
    description: str = ""
    version: str = ""
    endpoints: list[Endpoint] = Field(default_factory=list)
    docs_url: str = ""


class GeneratedFile(BaseModel):
    """A single file generated by the forge pipeline."""

    path: str  # Relative to the tool's output directory
    content: str
    language: str = "python"  # "python" | "json" | "toml" | "markdown"


class ForgeResult(BaseModel):
    """Complete result of a tool forge operation."""

    tool_name: str
    output_dir: str = ""
    files_created: list[str] = Field(default_factory=list)
    mcp_command: str = ""
    harness_updated: bool = False
    spec: APISpec | None = None
    generated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    error: str | None = None


# ---------------------------------------------------------------------------
# Engine
# ---------------------------------------------------------------------------


class ToolForgeEngine:
    """Auto-generates MCP server code and REST clients from API documentation.

    Pipeline:
        1. Fetch and parse API documentation via Tavily / direct HTTP.
        2. Use Fastino to extract a structured :class:`APISpec`.
        3. Render MCP server source files via Jinja2 (with inline fallback).
        4. Write files to ``mcp-servers/{tool_name}-mcp/``.
        5. Update ``tool-broker.md`` with a new entry.
        6. Return a :class:`ForgeResult`.

    Usage::

        config = HackForgeConfig.load()
        engine = ToolForgeEngine(config)
        result = await engine.forge_integration(
            tool_name="Tavily",
            api_docs_url="https://docs.tavily.com/docs/tavily-api/rest_api",
        )
        print(result.mcp_command)
    """

    def __init__(self, config: HackForgeConfig) -> None:
        self._config = config

    # ------------------------------------------------------------------
    # Public API
    # ------------------------------------------------------------------

    async def forge_integration(
        self, tool_name: str, api_docs_url: str
    ) -> ForgeResult:
        """Generate a complete MCP server for a discovered tool.

        Args:
            tool_name: Human-readable name of the tool (e.g. ``"Stripe"``).
            api_docs_url: URL pointing to the tool's API reference or docs.

        Returns:
            A :class:`ForgeResult` describing all generated files and the MCP
            command to add to Claude Code config.
        """
        logger.info("ToolForge: forging integration for %s (%s)", tool_name, api_docs_url)
        result = ForgeResult(tool_name=tool_name)

        try:
            # Step 1: fetch docs
            docs_text = await self._fetch_api_docs(api_docs_url)
            if not docs_text:
                result.error = f"Could not retrieve API docs from {api_docs_url}."
                return result

            # Step 2: extract spec
            spec = await self._extract_api_spec(docs_text, tool_name, api_docs_url)
            result.spec = spec
            logger.info(
                "ToolForge: extracted spec for %s — %d endpoints", tool_name, len(spec.endpoints)
            )

            # Step 3: generate files
            generated_files = await self._generate_mcp_server(spec, tool_name)

            # Step 4: write files
            output_dir = await self._write_files(generated_files, tool_name)
            result.output_dir = str(output_dir)
            result.files_created = [f.path for f in generated_files]

            # Step 5: update harness
            await self._update_harness(tool_name, spec)
            result.harness_updated = True

            # Build the mcp_command snippet
            slug = self._slugify(tool_name)
            result.mcp_command = (
                f"cd {output_dir} && uv run python server.py"
            )

            logger.info(
                "ToolForge: forge complete — %d files written to %s",
                len(generated_files),
                output_dir,
            )

        except Exception as exc:
            logger.exception("ToolForge: unexpected error for %s", tool_name)
            result.error = str(exc)

        return result

    # ------------------------------------------------------------------
    # Step 1: fetch docs
    # ------------------------------------------------------------------

    async def _fetch_api_docs(self, url: str) -> str:
        """Retrieve API documentation text via Tavily deep-fetch or HTTP.

        Tavily's advanced search mode extracts clean structured text from
        documentation pages, which is far better than raw HTML for LLM parsing.

        Args:
            url: URL of the API documentation page.

        Returns:
            Clean text content, or empty string on total failure.
        """
        from hackforge.providers.tavily_client import TavilyClient

        logger.debug("ToolForge: fetching docs from %s", url)

        # Primary: Tavily deep extraction
        try:
            async with TavilyClient(self._config.tavily) as client:
                resp = await client.search(
                    query=f"site:{url} API reference endpoints authentication",
                    max_results=5,
                    search_depth="advanced",
                    include_raw_content=True,
                )
                parts: list[str] = []
                if resp.answer:
                    parts.append(resp.answer)
                for result in resp.results:
                    content = result.raw_content or result.content
                    if content:
                        parts.append(content)
                if parts:
                    return "\n\n".join(parts)
        except Exception as exc:
            logger.warning("Tavily docs fetch failed: %s — trying direct HTTP", exc)

        # Fallback: direct HTTP
        try:
            async with httpx.AsyncClient(timeout=30, follow_redirects=True) as client:
                resp = await client.get(url, headers={"User-Agent": "HackForge/0.1"})
                resp.raise_for_status()
                return resp.text
        except Exception as exc:
            logger.error("Direct docs fetch failed for %s: %s", url, exc)
            return ""

    # ------------------------------------------------------------------
    # Step 2: extract API spec
    # ------------------------------------------------------------------

    async def _extract_api_spec(
        self, docs_text: str, tool_name: str, docs_url: str
    ) -> APISpec:
        """Use Fastino to parse documentation text into a structured APISpec.

        Sends up to 12 000 characters of documentation to Fastino's fast
        extraction endpoint and parses the JSON response.

        Args:
            docs_text: Raw documentation text.
            tool_name: Name of the tool for defaults.
            docs_url: Original docs URL (stored on the spec).

        Returns:
            A populated :class:`APISpec`.
        """
        chunk = docs_text[:12_000]
        prompt = (
            f"You are parsing API documentation for '{tool_name}'.\n\n"
            "Extract a complete API specification from the text below. "
            "Return ONLY valid JSON with this structure:\n"
            "{\n"
            '  "name": string,\n'
            '  "base_url": string (e.g. "https://api.example.com/v1"),\n'
            '  "auth_type": one of "api_key"|"oauth"|"bearer"|"none",\n'
            '  "auth_header": string (e.g. "Authorization" or "X-Api-Key"),\n'
            '  "description": string (1-2 sentences about the API),\n'
            '  "version": string (e.g. "v1"),\n'
            '  "endpoints": [\n'
            "    {\n"
            '      "method": "GET"|"POST"|"PUT"|"DELETE"|"PATCH",\n'
            '      "path": string (e.g. "/search"),\n'
            '      "description": string,\n'
            '      "params": [{"name": string, "type": string, "required": bool, '
            '"description": string}],\n'
            '      "response_schema": {"type": "object", "properties": {}},\n'
            '      "requires_auth": bool\n'
            "    }\n"
            "  ]\n"
            "}\n\n"
            f"DOCUMENTATION:\n{chunk}\n\nJSON:"
        )

        try:
            async with httpx.AsyncClient(timeout=self._config.fastino.timeout) as client:
                response = await client.post(
                    f"{self._config.fastino.base_url}/chat/completions",
                    headers={
                        "Authorization": f"Bearer {self._config.fastino.api_key}",
                        "Content-Type": "application/json",
                    },
                    json={
                        "model": "fastino-extract",
                        "messages": [{"role": "user", "content": prompt}],
                        "temperature": 0.1,
                        "max_tokens": 3000,
                    },
                )
                response.raise_for_status()
                data: dict[str, Any] = response.json()
                raw_json: str = (
                    data.get("choices", [{}])[0]
                    .get("message", {})
                    .get("content", "{}")
                )
                parsed = json.loads(raw_json)
                parsed.setdefault("name", tool_name)
                parsed.setdefault("docs_url", docs_url)

                endpoints_raw: list[dict[str, Any]] = parsed.pop("endpoints", [])
                spec = APISpec(**parsed)
                spec.endpoints = [Endpoint(**ep) for ep in endpoints_raw]
                spec.docs_url = docs_url
                return spec

        except Exception as exc:
            logger.warning(
                "Fastino spec extraction failed for %s: %s — using minimal spec",
                tool_name, exc,
            )
            return APISpec(name=tool_name, docs_url=docs_url)

    # ------------------------------------------------------------------
    # Step 3: generate MCP server code
    # ------------------------------------------------------------------

    async def _generate_mcp_server(
        self, spec: APISpec, tool_name: str
    ) -> list[GeneratedFile]:
        """Render MCP server source files from the API spec.

        Tries Jinja2 templates from the project ``templates/`` directory first;
        falls back to inline Python string templates if Jinja2 or the template
        files are not available.

        Files generated:
        - ``server.py``       — MCP server entry point.
        - ``client.py``       — Thin async REST client.
        - ``pyproject.toml``  — Project / dependency declaration.
        - ``README.md``       — Quick-start documentation.

        Args:
            spec: Parsed API specification.
            tool_name: Human-readable tool name.

        Returns:
            List of :class:`GeneratedFile` objects ready to be written to disk.
        """
        slug = self._slugify(tool_name)
        env_var = f"{slug.upper().replace('-', '_')}_API_KEY"

        files: list[GeneratedFile] = []
        files.append(self._render_server_py(spec, tool_name, slug, env_var))
        files.append(self._render_client_py(spec, tool_name, slug, env_var))
        files.append(self._render_pyproject_toml(tool_name, slug))
        files.append(self._render_readme(spec, tool_name, slug, env_var))

        return files

    def _render_server_py(
        self, spec: APISpec, tool_name: str, slug: str, env_var: str
    ) -> GeneratedFile:
        """Render the MCP server entry point (``server.py``).

        The server exposes each endpoint as an MCP tool using the FastMCP
        framework.  Each tool calls the thin REST client in ``client.py``.

        Args:
            spec: Parsed API spec.
            tool_name: Human-readable tool name.
            slug: URL-safe lowercase slug (e.g. ``"my-tool"``).
            env_var: Environment variable name for the API key.

        Returns:
            A :class:`GeneratedFile` for ``server.py``.
        """
        tool_registrations: list[str] = []
        for ep in spec.endpoints:
            func_name = self._endpoint_to_func_name(ep)
            params_signature = self._build_param_signature(ep)
            params_dict = self._build_params_dict(ep)
            doc = ep.description or f"{ep.method} {ep.path}"

            tool_registrations.append(
                f'@mcp.tool()\n'
                f'async def {func_name}({params_signature}) -> dict:\n'
                f'    """{doc}"""\n'
                f'    return await _client.request(\n'
                f'        method="{ep.method}",\n'
                f'        path="{ep.path}",\n'
                f'        params={{{params_dict}}},\n'
                f'    )\n'
            )

        if not tool_registrations:
            tool_registrations.append(
                '@mcp.tool()\n'
                'async def ping() -> dict:\n'
                '    """Health check — verifies the API key is working."""\n'
                '    return await _client.request(method="GET", path="/", params={})\n'
            )

        tools_block = "\n\n".join(tool_registrations)

        content = f'''\
"""MCP Server for {tool_name}.

Auto-generated by HackForge ToolForge on {datetime.now(timezone.utc).strftime("%Y-%m-%d")}.
DO NOT EDIT — re-generate with: hackforge forge {tool_name}
"""
from __future__ import annotations

import os
import asyncio
from mcp.server.fastmcp import FastMCP

from client import {self._to_class_name(tool_name)}Client

# ---------------------------------------------------------------------------
# MCP server instance
# ---------------------------------------------------------------------------

mcp = FastMCP(
    name="{tool_name} MCP",
    version="0.1.0",
    description="{spec.description or tool_name + ' API integration'}",
)

# Shared async REST client — initialised once at startup
_client: {self._to_class_name(tool_name)}Client


@mcp.startup()
async def _startup() -> None:
    global _client
    api_key = os.environ.get("{env_var}", "")
    if not api_key:
        raise RuntimeError(
            "{env_var} environment variable is not set. "
            "Set it before starting this MCP server."
        )
    _client = {self._to_class_name(tool_name)}Client(api_key=api_key)


@mcp.shutdown()
async def _shutdown() -> None:
    await _client.close()


# ---------------------------------------------------------------------------
# Tool definitions
# ---------------------------------------------------------------------------

{tools_block}

# ---------------------------------------------------------------------------
# Entry point
# ---------------------------------------------------------------------------

if __name__ == "__main__":
    mcp.run()
'''
        return GeneratedFile(path="server.py", content=content, language="python")

    def _render_client_py(
        self, spec: APISpec, tool_name: str, slug: str, env_var: str
    ) -> GeneratedFile:
        """Render the thin async REST client (``client.py``).

        Args:
            spec: Parsed API spec.
            tool_name: Human-readable tool name.
            slug: URL-safe slug.
            env_var: Environment variable name for the API key.

        Returns:
            A :class:`GeneratedFile` for ``client.py``.
        """
        class_name = self._to_class_name(tool_name)
        auth_header = spec.auth_header or "Authorization"
        auth_value_expr = (
            f'"Bearer {{self._api_key}}"'
            if spec.auth_type in ("bearer", "oauth")
            else f'"{{self._api_key}}"'
        )

        content = f'''\
"""Async REST client for {tool_name}.

Auto-generated by HackForge ToolForge on {datetime.now(timezone.utc).strftime("%Y-%m-%d")}.
"""
from __future__ import annotations

from typing import Any

import httpx


class {class_name}Client:
    """Thin async HTTP client for the {tool_name} API.

    Args:
        api_key: Your {tool_name} API key (set via ``{env_var}``).
        base_url: Override the default base URL.
        timeout: Request timeout in seconds.
    """

    BASE_URL = "{spec.base_url or 'https://api.example.com/v1'}"

    def __init__(
        self,
        api_key: str,
        base_url: str = "",
        timeout: int = 30,
    ) -> None:
        self._api_key = api_key
        self._base_url = base_url or self.BASE_URL
        self._timeout = timeout
        self._http: httpx.AsyncClient | None = None

    async def _ensure_client(self) -> None:
        if self._http is None:
            self._http = httpx.AsyncClient(
                base_url=self._base_url,
                timeout=self._timeout,
                headers={{
                    "{auth_header}": {auth_value_expr},
                    "Content-Type": "application/json",
                }},
            )

    async def close(self) -> None:
        """Close the underlying HTTP connection pool."""
        if self._http is not None:
            await self._http.aclose()
            self._http = None

    async def request(
        self,
        method: str,
        path: str,
        params: dict[str, Any] | None = None,
    ) -> dict[str, Any]:
        """Send an authenticated HTTP request.

        Args:
            method: HTTP verb (``"GET"``, ``"POST"``, etc.).
            path: Path relative to :attr:`BASE_URL`.
            params: Query params for GET requests; JSON body for POST/PUT/PATCH.

        Returns:
            Parsed JSON response as a dict.

        Raises:
            httpx.HTTPStatusError: On 4xx/5xx responses.
        """
        await self._ensure_client()
        assert self._http is not None

        params = params or {{}}
        if method.upper() in ("GET", "DELETE"):
            resp = await self._http.request(method, path, params=params)
        else:
            resp = await self._http.request(method, path, json=params)

        resp.raise_for_status()
        return resp.json()
'''
        return GeneratedFile(path="client.py", content=content, language="python")

    def _render_pyproject_toml(self, tool_name: str, slug: str) -> GeneratedFile:
        """Render ``pyproject.toml`` for the generated MCP server package.

        Args:
            tool_name: Human-readable tool name.
            slug: Package slug.

        Returns:
            A :class:`GeneratedFile` for ``pyproject.toml``.
        """
        content = f'''\
[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "{slug}-mcp"
version = "0.1.0"
description = "MCP server for {tool_name} — auto-generated by HackForge"
requires-python = ">=3.11"
dependencies = [
    "mcp[cli]>=1.0",
    "httpx>=0.27",
    "pydantic>=2.0",
]

[project.scripts]
serve = "server:main"

[tool.hatch.build.targets.wheel]
packages = ["."]
'''
        return GeneratedFile(path="pyproject.toml", content=content, language="toml")

    def _render_readme(
        self, spec: APISpec, tool_name: str, slug: str, env_var: str
    ) -> GeneratedFile:
        """Render a ``README.md`` quickstart guide for the generated server.

        Args:
            spec: Parsed API spec.
            tool_name: Human-readable tool name.
            slug: URL-safe slug.
            env_var: Environment variable name for the API key.

        Returns:
            A :class:`GeneratedFile` for ``README.md``.
        """
        endpoints_table = "| Method | Path | Description |\n|--------|------|-------------|\n"
        for ep in spec.endpoints[:20]:  # cap at 20 for readability
            endpoints_table += f"| {ep.method} | `{ep.path}` | {ep.description} |\n"

        content = f'''\
# {tool_name} MCP Server

> Auto-generated by HackForge ToolForge on {datetime.now(timezone.utc).strftime("%Y-%m-%d")}.

{spec.description or f"MCP server that exposes the {tool_name} API as Claude tools."}

## Quick Start

```bash
# 1. Set your API key
export {env_var}=your-api-key-here

# 2. Install dependencies
uv pip install -e .

# 3. Run the server
uv run python server.py
```

## Add to Claude Code

Add to your `.claude/settings.json`:

```json
{{
  "mcpServers": {{
    "{slug}": {{
      "command": "uv",
      "args": ["run", "python", "server.py"],
      "cwd": "mcp-servers/{slug}-mcp",
      "env": {{
        "{env_var}": "${{env:{env_var}}}"
      }}
    }}
  }}
}}
```

## Available Endpoints

{endpoints_table}

## Auth

Auth type: `{spec.auth_type}`
Header: `{spec.auth_header}`
Docs: {spec.docs_url}
'''
        return GeneratedFile(path="README.md", content=content, language="markdown")

    # ------------------------------------------------------------------
    # Step 4: write files
    # ------------------------------------------------------------------

    async def _write_files(
        self, files: list[GeneratedFile], tool_name: str
    ) -> Path:
        """Write generated files to ``mcp-servers/{tool_name}-mcp/``.

        Creates the directory if it does not exist.  Existing files are
        overwritten so that re-forging always produces a clean result.

        Args:
            files: List of :class:`GeneratedFile` objects to write.
            tool_name: Tool name (used to construct the output directory).

        Returns:
            Path to the output directory.
        """
        slug = self._slugify(tool_name)
        output_dir = self._config.project_root / "mcp-servers" / f"{slug}-mcp"
        output_dir.mkdir(parents=True, exist_ok=True)

        for gf in files:
            target = output_dir / gf.path
            target.parent.mkdir(parents=True, exist_ok=True)
            target.write_text(gf.content, encoding="utf-8")
            logger.debug("ToolForge: wrote %s", target)

        logger.info("ToolForge: wrote %d file(s) to %s", len(files), output_dir)
        return output_dir

    # ------------------------------------------------------------------
    # Step 5: update harness
    # ------------------------------------------------------------------

    async def _update_harness(self, tool_name: str, spec: APISpec) -> None:
        """Append a new entry to the harness ``tool-broker.md`` file.

        Creates the file with a header if it does not already exist.

        Args:
            tool_name: Name of the newly integrated tool.
            spec: Parsed API spec (used for description and endpoint count).
        """
        broker_path = self._config.project_root / "tool-broker.md"

        # Ensure the file exists with a header
        if not broker_path.exists():
            broker_path.write_text(
                "# Harness Tool Broker\n\n"
                "Auto-managed by HackForge ToolForge. "
                "Each entry represents an integrated MCP tool.\n\n",
                encoding="utf-8",
            )

        slug = self._slugify(tool_name)
        existing = broker_path.read_text(encoding="utf-8")

        # Skip if already present
        if f"## {tool_name}" in existing:
            logger.debug("ToolForge: %s already in tool-broker.md", tool_name)
            return

        entry = (
            f"\n## {tool_name}\n\n"
            f"- **MCP server**: `mcp-servers/{slug}-mcp/`\n"
            f"- **Auth**: {spec.auth_type}\n"
            f"- **Base URL**: {spec.base_url or 'see README'}\n"
            f"- **Endpoints**: {len(spec.endpoints)}\n"
            f"- **Description**: {spec.description or 'No description extracted.'}\n"
            f"- **Docs**: {spec.docs_url}\n"
            f"- **Added**: {datetime.now(timezone.utc).strftime('%Y-%m-%d')}\n"
        )

        with broker_path.open("a", encoding="utf-8") as f:
            f.write(entry)

        logger.info("ToolForge: updated tool-broker.md with %s entry", tool_name)

    # ------------------------------------------------------------------
    # Rendering helpers
    # ------------------------------------------------------------------

    @staticmethod
    def _slugify(name: str) -> str:
        """Convert a tool name to a URL-safe lowercase slug.

        Args:
            name: Tool name (e.g. ``"My Tool v2"``).

        Returns:
            Slug string (e.g. ``"my-tool-v2"``).
        """
        slug = name.lower().strip()
        slug = re.sub(r"[^a-z0-9]+", "-", slug)
        slug = slug.strip("-")
        return slug

    @staticmethod
    def _to_class_name(tool_name: str) -> str:
        """Convert a tool name to a PascalCase class name.

        Args:
            tool_name: E.g. ``"my tool"`` → ``"MyTool"``.

        Returns:
            PascalCase string safe for use as a Python class name.
        """
        return "".join(
            word.capitalize()
            for word in re.split(r"[\s_\-]+", tool_name)
            if word
        )

    @staticmethod
    def _endpoint_to_func_name(ep: Endpoint) -> str:
        """Convert an endpoint definition to a valid Python function name.

        Examples:
            GET  /search          → ``get_search``
            POST /chat/completions → ``post_chat_completions``

        Args:
            ep: Endpoint to convert.

        Returns:
            Snake-case function name string.
        """
        method = ep.method.lower()
        path_part = re.sub(r"[^a-z0-9]+", "_", ep.path.lower()).strip("_")
        name = f"{method}_{path_part}" if path_part else method
        # Remove duplicate underscores
        name = re.sub(r"_+", "_", name)
        return name or "call"

    @staticmethod
    def _build_param_signature(ep: Endpoint) -> str:
        """Build a Python function signature string from an endpoint's params.

        All parameters are typed as ``str`` with a default of ``""`` to keep
        the generated code simple and LLM-friendly.

        Args:
            ep: Endpoint whose params to convert.

        Returns:
            Comma-separated parameter string (e.g. ``"query: str = '', limit: str = ''"``.
        """
        if not ep.params:
            return ""
        parts: list[str] = []
        for p in ep.params:
            pname = re.sub(r"[^a-z0-9_]", "_", str(p.get("name", "param")).lower())
            required = p.get("required", False)
            if required:
                parts.append(f"{pname}: str")
            else:
                parts.append(f"{pname}: str = ''")
        return ", ".join(parts)

    @staticmethod
    def _build_params_dict(ep: Endpoint) -> str:
        """Build a Python dict literal string from an endpoint's params.

        Args:
            ep: Endpoint whose params to convert.

        Returns:
            Dict literal string (e.g. ``'"query": query, "limit": limit'``).
        """
        if not ep.params:
            return ""
        parts: list[str] = []
        for p in ep.params:
            pname = re.sub(r"[^a-z0-9_]", "_", str(p.get("name", "param")).lower())
            parts.append(f'"{p.get("name", pname)}": {pname}')
        return ", ".join(parts)
